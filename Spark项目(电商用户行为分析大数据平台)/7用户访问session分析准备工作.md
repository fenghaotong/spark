# 用户访问session分析准备工作

**开发配置管理组件**

[开发配置管理组件main](src/conf/ConfigurationManager.java)

[开发配置管理组件test](src/conf/ConfigurationManagerTest.java)

**JDBC原理介绍以及增删改查示范**

- Java程序/J2EE程序，当需要操作数据库，通常就是对数据库中某一个，或者某些表，进行增删改查，那么就需要通过某些方式连接到数据库，比如MySQL，执行各种SQL语句（insert、select、udpate）
- JDBC，Java Database Connectivity，Java数据库连接技术。
- JDBC，其实只是代表了JDK提供的一套面向数据库的一套开发接口，注意，这里大部分仅仅是接口而已，换句话说，Java应用程序，光有JDBC，是操作不了数据库的，更不用谈所谓的CRUD，增删改查。因为JDBC只是一套接口而已，JDBC真正的意义在于通过接口统一了java程序对各种数据库的访问的规范
- 数据库厂商提供的JDBC驱动，JDBC Driver。数据库厂商，比如说，MySQL公司，或者Oracle公司，会针对JDBC的一套接口，提供完整的一套接口的实现类，在这套实现类中，不同的数据库厂商就实现了针对自己数据库的一套连接、执行SQL语句等等实际的功能，写入MySQL数据库。

[增删改查](src/JdbcCRUD.java)

**数据库连接池原理**

- 每一次java程序要在MySQL中执行一条SQL语句，那么就必须建立一个Connection对象，代表了与MySQL数据库的连接。然后在通过连接发送了你要执行的SQL语句之后，就会调用Connection.close()来关闭和销毁与数据库的连接。为什么要立即关闭呢？因为数据库的连接是一种很重的资源，代表了网络连接、IO等资源。所以如果不使用的话，就需要尽早关闭，以避免资源浪费。
- 劣势/不足：如果要频繁地操作MySQL的话，那么就势必会频繁地创建Connection对象，底层建立起与MySQL的占用了网络资源、IO资源的连接。此外呢，每次使用完Connection对象之后，都必须将Connection连接给关闭，又涉及到频繁的网络资源、IO资源的关闭和释放。
  - 如上所述，如果频繁的开关Connection连接，那么会造成大量的对网络、IO资源的申请和释放的无谓的时间的耗费
  - 对于特别频繁的数据库操作，比如100次/s，那么可能会导致性能急剧下降。

- 数据库连接池，会自己在内部持有一定数量的数据库连接，比如通常可能是100~1000个左右。然后每次java程序要通过数据库连接往MySQL发送SQL语句的时候，都会从数据库连接池中获取一个连接，然后通过它发送SQL语句。SQL语句执行完之后，不会调用Connection.close()，而是将连接还回数据库连接池里面去。
- 下一次，java程序再需要操作数据库的时候，就还是重复以上步骤，获取连接、发送SQL、还回连接。
- 数据库连接池的好处：
  1. java程序不用自己去管理Connection的创建和销毁，代码上更加方便。
  2. 程序中只有固定数量的数据库连接，不会一下子变得很多，而且也不会进行销毁。那么对于短时间频繁进行数据库操作的业务来说。就有很高的意义和价值。也就是说，如果短时间内，频繁操作10000次，不需要对数据库连接创建和销毁10000次。这样的话，可以大幅度节省我们的数据库连接的创建和销毁的资源开销以及时间开销。
  3. 最终可以提升整个应用程序的性能。

在spark作业中，通常来说，都需要使用数据库连接池。当然，可以使用开源的数据库连接池，功能非常强大，比如C3P0、DBCP等等。但是呢，对于某些简单的情况下，我们也可以自己编写一个简单的数据库连接池即可。

而且在spark作业中，是非常适合使用数据库连接池的，为什么呢？因此spark计算出来的结果，可能数据量还是会比较大的。比如说10万条。那么如果用普通的数据库操作方式，就必须创建和销毁数据库连接10万次，那么会大大降低整个spark作业的性能。数据库的操作变成整个spark作业的瓶颈。

如果可以善用数据库连接池的话，那么就大大节省数据库连接的创建和销毁的时间和性能开销。大大提升spark作业的整体性能。

**单例设计模式**

[单例设计模式demo](src/test/Singleton.java)

**内部类以及匿名内部类**

- 最普通的，我们平时见到的那种类，就是在一个后缀为.java的文件中，直接定义的类，比如:

  ```java
  public class student(){
      private String name;
      private int age;
  }
  ```

- 内部类，顾名思义，就是包含在外部类中的类，就叫做内部类。内部类有两种，一种是静态内部类，一种是非静态内部类。

  ```java
  public class School {
    private static School instance = null;
    static class Teacher {}
  }
  
  public class School {
    private String name;
    class Teacher {}
  }
  
  ```

- 静态内部类和非静态内部类之间的区别主要如下：

  1. 内部原理的区别：

     静态内部类是属于外部类的类成员，是一种静态的成员，是属于类的，就有点类似于private static Singleton instance = null；非静态内部类，是属于外部类的实例对象的一个实例成员，也就是说，每个非静态内部类，不是属于外部类的，是属于外部类的每一个实例的，创建非静态内部类的实例以后，非静态内部类实例，是必须跟一个外部类的实例进行关联和有寄存关系的。

  2. 创建方式的区别：

     创建静态内部类的实例的时候，只要直接使用“外部类.内部类()”的方式，就可以，比如`new School.Teacher()`；创建非静态内部类的实例的时候，必须要先创建一个外部类的实例，然后通过外部类的实例，再来创建内部类的实例，`new School().Teader()`

     > 通常来说一般选择使用静态内部类。

- 匿名内部类：

  ```java
  public interface ISayHello {
    String sayHello(String name);
  }
  
  public class SayHelloTest {
    public static void main(String[] args) {
      ISayHello obj = new ISayHello() {
        public String sayHello(String name) { return "hello, " + name }
      }
      System.out.println(obj.sayHello("leo"))
    }
  }
  ```

  匿名内部类的使用场景，通常来说，就是在一个内部类，只要创建一次，使用一次，以后就不再使用的情况下，就可以。那么，此时，通常不会选择在外部创建一个类，而是选择直接创建一个实现了某个接口、或者继承了某个父类的内部类，而且通常是在方法内部，创建一个匿名内部类。

  在使用java进行spark编程的时候，如果使用的是java7以及之前的版本，那么通常在对某个RDD执行算子，并传入算子的函数的时候，通常都会传入一个实现了某个Spark Java API中Function接口的匿名内部类。

**开发JDBC辅助组件**

[JDBC辅助组件](src/jdbc/JDBCHelper.java)

**JavaBean概念**

- JavaBean，虽然就是一个类，但是是有特殊条件的一个类，不是所有的类都可以叫做JavaBean的
- 首先，它需要有一些field，这些field，都必须用private来修饰，表示所有的field，都是私有化的，不能随意的获取和设置
- 其次，需要给所有的field，都提供对应的setter和getter方法，什么叫setter和getter？setter，就是说setX()方法，用于给某个field设置值；getter，就是说getX()方法，用于对某个field获取值
- JavaBean通常怎么用？通常来说，会将一个JavaBean，与数据库中的某个表一一对应起来，比如说，有一个student表，`create table student(name varchar(30), age integer)`，那么这个表，如果要操作的话，通常来说，会在程序中，建立一个对应的JavaBean，这个JavaBean中，所有的field，都是和表中的字段一一对应起来的。
- 然后呢，在执行增删改查操作的时候，其实都是面向JavaBean来操作的，比如`insertStudent()`方法，就应该接收一个参数，Student对象；`findAllStudent()`方法，就应该将返回类型设置为`List<Student>`列表

**domain的概念**

- 在系统中，通常会分很多层，比如经典的三层架构，控制层、业务层、数据访问层（DAO层）此外，还有一个层，就是domain层，通常就是用于放置这个系统中，与数据库中的表，一一对应起来的JavaBean

- 三层架构+domain层+model层（J2EE web系统）

- 浏览器->后台->控制层->业务层->数据访问层->数据库

  ​    			    domain->domain->domain->SQL

   							  domain/model<-

- domain和model可能都是JavaBean；之间的区别，只是用途不太一样，domain通常就代表了与数据库表一一对应的JavaBean；model通常代表了不与数据库一一对应的JavaBean，但是封装的数据，是前端的JS脚本，需要使用的一些数据。

**DAO模式**

- Data Access Object：数据访问对象
- 首先，你的应用程序，肯定会有业务逻辑的代码。在三层架构的web系统中，业务逻的代码，就是在你的Service组件里面；在我们的spark作业中，业务逻辑代码就是在我们的spark作业里面。
- 如果说，你不用DAO模式的话，那么所有的数据库访问的代码和逻辑会全部耦合在业务逻辑代码里面。比如，你的业务逻辑代码中，可能会充斥着JDBCHelper，定义SQL语句，处理查询返回结果等等代码。会导致业务逻辑和数据访问严重耦合。导致以后如果你只是想修改数据访问的代码，那么还得在一大堆业务逻辑的代码中去找，找到这段代码，然后去做对应的修改。
- 因为我们要将数据库访问的代码，封装在DAO中，然后呢，业务逻辑的代码，就可以直接去调用DAO组件，实现数据库操作的逻辑。如果这样做了以后，那么在业务逻辑的代码中，就不可能出现SQL语句、查询结果处理等等这些东西。当后面对系统进行维护的时候，如果你只是要优化一条SQL语句，那么你肯定不用跑到业务逻辑的代码里面去找到这条SQL语句，然后去修改它。
- 只需要到业务逻辑代码调用的DAO组件里面去，找到对应的SQL语句，修改，即可。
- 引入了DAO模式以后，就大大降低了业务逻辑层和数据访问层的耦合，大大提升了后期的系统维护的效率，并降低了时间成本。
- 我们自己在实现DAO模式的时候，通常来说，会将其分为两部分，一个是DAO接口；一个是DAO实现类。我们的业务的代码，通常就是面向接口进行编程；那么当接口的实现需要改变的时候，直接定义一个新的实现即可。但是对于我们的业务代码来说，只要面向接口开发就可以了。DAO的改动对业务代码应该没有任何的影响。

[Task](src/domain/Task.java)

[ITaskDAO](src/dao/ITaskDAO.java)

[TaskDAOImpl](src/dao/impl/TaskDAOImpl.java)

**工厂模式讲解**

如果没有工厂模式，可能会出现的问题：

- `ITaskDAO`接口和`TaskDAOImpl`实现类；实现类是可能会更换的；那么，如果你就使用普通的方式来创建DAO，比如`ITaskDAO taskDAO = new TaskDAOImpl()`，那么后续，如果你的TaskDAO的实现类变更了，那么你就必须在你的程序中，所有出现过TaskDAOImpl的地方，去更换掉这个实现类。这是非常非常麻烦的。
- 如果说，你的TaskDAOImpl这个类，在你的程序中出现了100次，那么你就需要修改100个地方。这对程序的维护是一场灾难。

工厂设计模式

- 对于一些种类的对象，使用一个工厂，来提供这些对象创建的方式，外界要使用某个类型的对象时，就直接通过工厂来获取即可。不用自己手动一个一个地方的去创建对应的对象。
- 那么，假使我们有100个地方用到了TaskDAOImpl。不需要去在100个地方都创建TaskDAOImpl()对象，只要在100个地方，都使用TaskFactory.getTaskDAO()方法，获取出来ITaskDAO接口类型的对象即可。
- 如果后面，比如说MySQL迁移到Oracle，我们重新开发了一套TaskDAOImpl实现类，那么就直接在工厂方法中，更换掉这个类即可。不需要再所有使用到的地方都去修改。

[DAOFactory](src/dao/impl/DAOFactory.java)

[TaskDAOTest](src/test/TaskDAOTest.java)

**JSON数据格式**

- JSON是一种数据格式；比如说，我们现在规定，有一个txt文本文件，用来存放一个班级的成绩；然后呢，我们规定，这个文本文件里的学生成绩的格式，是第一行，就是一行列头`（姓名 班级 年级 科目 成绩）`，接下来，每一行就是一个学生的成绩。那么，这个文本文件内的这种信息存放的格式，其实就是一种数据格式。

```text
学生 班级 年级 科目 成绩
张三 一班 大一 高数 90
李四 二班 大一 高数 80
```

- 对应到JSON，它其实也是代表了一种数据格式，所谓数据格式，就是数据组织的形式。比如说，刚才所说的学生成绩，用JSON格式来表示的话，如下：

```json
[{"学生":"张三", "班级":"一班", "年级":"大一", "科目":"高数", "成绩":90}, {"学生":"李四", "班级":"二班", "年级":"大一", "科目":"高数", "成绩":80}]
```

- JSON，很简单，就是对同样一批数据的，不同的一种数据表示的形式。

- JSON的数据语法，其实很简单：如果是包含多个数据实体的话，比如说多个学生成绩，那么需要使用数组的表现形式，就是`[]`。对于单个数据实体，比如一个学生的成绩，那么使用一个`{}`来封装数据，对于数据实体中的每个字段以及对应的值，使用key:value的方式来表示，多个key-value对之间用逗号分隔；多个`{}`代表的数据实体之间，用逗号分隔。

- JSON在企业级项目开发过程中，扮演的角色是无比重要的。最常用的地方，莫过于基于Ajax的前端和后端程序之间的通信。比如说，在前端页面中，可以不刷新页面，直接发送一个Ajax异步请求到后端，后端返回一个JSON格式的数据，然后前端使用JSON格式的数据，渲染页面中的对应地方的信息。
- 在我们的项目中，JSON是起到了什么作用呢？我们在task表中的task_param字段，会存放不同类型的任务对应的参数。比如说，用户访问session分析模块与页面单跳转化率统计模块的任务参数是不同的，但是，使用同一张task表来存储所有类型的任务。那么，你怎么来存储不同类型的任务的不同的参数呢？你的表的字段是事先要定好的呀。
- 所以采取了用一个task_param字段，来存储不同类型的任务的参数的方式。task_param字段中，实际上会存储一个任务所有的字段，使用JSON的格式封装所有任务参数，并存储在task_param字段中。就实现了非常灵活的方式。

如何来操作JSON格式的数据？

- 比如说，要获取JSON中某个字段的值。可以使用的是阿里的fastjson工具包。使用这个工具包，可以方便的将字符串类型的JSON数据，转换为一个JSONObject对象，然后通过其中的getX()方法，获取指定的字段的值。

[FastjsonTest](src/test/FastjsonTest.java)

